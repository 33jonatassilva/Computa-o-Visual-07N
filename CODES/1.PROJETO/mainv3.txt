// Copyright (c) 2025 Andre Kishimoto - https://kishimoto.com.br/
// SPDX-License-Identifier: Apache-2.0

//------------------------------------------------------------------------------
// Exemplo: 04-invert_image
// O programa carrega o arquivo de imagem indicado na constante IMAGE_FILENAME
// e exibe o conteúdo na janela ("kodim23.png" pertence ao "Kodak Image Set").
// A tecla '1' aplica uma transformação de intensidade (negativo da imagem).
// Caso a imagem seja maior do que WINDOW_WIDTHxWINDOW_HEIGHT, a janela é
// redimensionada logo após a imagem ser carregada.
//
// Observação:
// Em um projeto mais realista, o código abaixo provavelmente seria refatorado.
// Alguns exemplos de refatoração do projeto:
// - Uso de headers (.h) e outros arquivos .c (ex. estruturas e operações
//   relacionadas à imagens);
// - Remoção de variáveis globais;
// - Redução de logs (ou melhor, seriam desativados na build release);
// - Arquivo de imagem seria um parâmetro do programa (argv), ao invés de ser
//   uma string constante IMAGE_FILENAME.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>
#include <SDL3_image/SDL_image.h>
#include <SDL3_ttf/SDL_ttf.h>

//------------------------------------------------------------------------------
// Custom types, structs, constants, etc.
//------------------------------------------------------------------------------
static const char *WINDOW_TITLE = "Invert image";
static const char *FONT_FILENAME = "arial.ttf"; // <-- ADICIONADO
static const int FONT_SIZE = 18;                 // <-- ADICIONADO
static const int MAX_BAR;

enum constants
{
    DEFAULT_WINDOW_WIDTH = 640,
    DEFAULT_WINDOW_HEIGHT = 480,

    DEFAULT_H_WINDOW_WIDTH = 540,
    DEFAULT_H_WINDOW_HEIGHT = 580,
};

typedef struct MyWindow MyWindow;
struct MyWindow
{
    SDL_Window *window;
    SDL_Renderer *renderer;
};

typedef struct MyImage MyImage;
struct MyImage
{
    SDL_Surface *surface;
    SDL_Texture *texture;
    SDL_FRect rect;
};

//------------------------------------------------------------------------------
// Globals (argh!)
//------------------------------------------------------------------------------
static MyWindow g_window = { .window = NULL, .renderer = NULL };
static MyWindow h_window = { .window = NULL, .renderer = NULL };
static MyImage g_image = {
    .surface = NULL,
    .texture = NULL,
    .rect = { .x = 0.0f, .y = 0.0f, .w = 0.0f, .h = 0.0f }
};

int histogram[256] = { 0 };
static TTF_Font *g_font = NULL;

//------------------------------------------------------------------------------
// Function declaration
//------------------------------------------------------------------------------

static void render_text(SDL_Renderer *renderer, const char *text, int x, int y, SDL_Color color);
static bool MyWindow_initialize(MyWindow *window, const char *title, int width, int height, SDL_WindowFlags window_flags);
static void MyWindow_destroy(MyWindow *window);
static void MyImage_destroy(MyImage *image);
static void load_rgba32(const char *filename, SDL_Renderer *renderer, MyImage *output_image);
static void invert_image(SDL_Renderer *renderer, MyImage *image);

//------------------------------------------------------------------------------
// Implementação de render_text  // <-- ADICIONADO
//------------------------------------------------------------------------------
static void render_text(SDL_Renderer *renderer, const char *text, int x, int y, SDL_Color color)
{
    if (!g_font)
    {
        SDL_Log("Erro: Fonte não carregada (g_font é NULL).");
        return;
    }

    // SDL3_ttf exige wrapLength, usamos 0 para "sem quebra de linha"
    SDL_Surface *text_surface = TTF_RenderText_Solid(g_font, text, 0, color);
    if (!text_surface)
    {
        SDL_Log("Erro ao criar a superfície de texto: %s", SDL_GetError());
        return;
    }

    SDL_Texture *text_texture = SDL_CreateTextureFromSurface(renderer, text_surface);
    if (!text_texture)
    {
        SDL_Log("Erro ao criar a textura de texto: %s", SDL_GetError());
        SDL_DestroySurface(text_surface);
        return;
    }

    SDL_FRect dest_rect = {
        .x = (float)x,
        .y = (float)y,
        .w = (float)text_surface->w,
        .h = (float)text_surface->h
    };

    SDL_RenderTexture(renderer, text_texture, NULL, &dest_rect);
    SDL_DestroyTexture(text_texture);
    SDL_DestroySurface(text_surface);
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
bool MyWindow_initialize(MyWindow *window, const char *title, int width, int height, SDL_WindowFlags window_flags)
{
    SDL_Log("\tMyWindow_initialize(%s, %d, %d)", title, width, height);
    return SDL_CreateWindowAndRenderer(title, width, height, window_flags, &window->window, &window->renderer);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void MyWindow_destroy(MyWindow *window)
{
    SDL_Log(">>> MyWindow_destroy()");

    SDL_Log("\tDestruindo MyWindow->renderer...");
    SDL_DestroyRenderer(window->renderer);
    window->renderer = NULL;

    SDL_Log("\tDestruindo MyWindow->window...");
    SDL_DestroyWindow(window->window);
    window->window = NULL;

    SDL_Log("<<< MyWindow_destroy()");
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void MyImage_destroy(MyImage *image)
{
    SDL_Log(">>> MyImage_destroy()");

    if (!image)
    {
        SDL_Log("\t*** Erro: Imagem inválida (image == NULL).");
        SDL_Log("<<< MyImage_destroy()");
        return;
    }

    if (image->texture)
    {
        SDL_Log("\tDestruindo MyImage->texture...");
        SDL_DestroyTexture(image->texture);
        image->texture = NULL;
    }

    if (image->surface)
    {
        SDL_Log("\tDestruindo MyImage->surface...");
        SDL_DestroySurface(image->surface);
        image->surface = NULL;
    }

    SDL_Log("\tRedefinindo MyImage->rect...");
    image->rect.x = image->rect.y = image->rect.w = image->rect.h = 0.0f;

    SDL_Log("<<< MyImage_destroy()");
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void load_rgba32(const char *filename, SDL_Renderer *renderer, MyImage *output_image)
{
    SDL_Log(">>> load_rgba32(\"%s\")", filename);

    if (!filename)
    {
        SDL_Log("\t*** Erro: Nome do arquivo inválido (filename == NULL).");
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    if (!renderer)
    {
        SDL_Log("\t*** Erro: Renderer inválido (renderer == NULL).");
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    if (!output_image)
    {
        SDL_Log("\t*** Erro: Imagem de saída inválida (output_image == NULL).");
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    MyImage_destroy(output_image);

    SDL_Log("\tCarregando imagem \"%s\" em uma superfície...", filename);
    SDL_Surface *surface = IMG_Load(filename);
    if (!surface)
    {
        SDL_Log("\t*** Erro ao carregar a imagem: %s", SDL_GetError());
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    SDL_Log("\tConvertendo superfície para formato RGBA32...");
    output_image->surface = SDL_ConvertSurface(surface, SDL_PIXELFORMAT_RGBA32);
    SDL_DestroySurface(surface);
    if (!output_image->surface)
    {
        SDL_Log("\t*** Erro ao converter superfície para formato RGBA32: %s", SDL_GetError());
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    SDL_Log("\tCriando textura a partir da superfície...");
    output_image->texture = SDL_CreateTextureFromSurface(renderer, output_image->surface);
    if (!output_image->texture)
    {
        SDL_Log("\t*** Erro ao criar textura: %s", SDL_GetError());
        SDL_Log("<<< load_rgba32(\"%s\")", filename);
        return;
    }

    SDL_Log("\tObtendo dimensões da textura...");
    SDL_GetTextureSize(output_image->texture, &output_image->rect.w, &output_image->rect.h);

    SDL_Log("<<< load_rgba32(\"%s\")", filename);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void invert_image(SDL_Renderer *renderer, MyImage *image)
{
    SDL_Log(">>> invert_image()");

    if (!renderer)
    {
        SDL_Log("\t*** Erro: Renderer inválido (renderer == NULL).");
        SDL_Log("<<< invert_image()");
        return;
    }

    if (!image || !image->surface)
    {
        SDL_Log("\t*** Erro: Imagem inválida (image == NULL ou image->surface == NULL).");
        SDL_Log("<<< invert_image()");
        return;
    }

    SDL_LockSurface(image->surface);

    const SDL_PixelFormatDetails *format = SDL_GetPixelFormatDetails(image->surface->format);
    const size_t pixelCount = image->surface->w * image->surface->h;

    Uint32 *pixels = (Uint32 *)image->surface->pixels;
    Uint8 r = 0;
    Uint8 g = 0;
    Uint8 b = 0;
    Uint8 a = 0;
    bool escaladecinza = true;

    for (size_t i = 0; i < pixelCount; ++i)
    {
        SDL_GetRGBA(pixels[i], format, NULL, &r, &g, &b, &a);

        if (!(r == g && g == b))
            escaladecinza = false;
    }

    float y = 0.0f;
    if (!escaladecinza)
    {
        for (size_t i = 0; i < pixelCount; ++i)
        {
            SDL_GetRGBA(pixels[i], format, NULL, &r, &g, &b, &a);

            y = 0.2125 * r + 0.7154 * g + 0.0721 * b;
            r = y;
            g = y;
            b = y;

            pixels[i] = SDL_MapRGBA(format, NULL, r, g, b, a);
        }
    }
    SDL_UnlockSurface(image->surface);

    SDL_DestroyTexture(image->texture);
    image->texture = SDL_CreateTextureFromSurface(renderer, image->surface);

    SDL_Log("<<< invert_image()");
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
static SDL_AppResult initialize(void)
{
    SDL_Log(">>> initialize()");

    SDL_Log("\tIniciando SDL...");
    if (!SDL_Init(SDL_INIT_VIDEO))
    {
        SDL_Log("\t*** Erro ao iniciar a SDL: %s", SDL_GetError());
        SDL_Log("<<< initialize()");
        return SDL_APP_FAILURE;
    }

    SDL_Log("\tIniciando SDL_ttf..."); // <-- MODIFICADO
    if (TTF_Init() != 1) // <-- MODIFICADO
    {
        SDL_Log("\t*** Erro ao iniciar a SDL_ttf: %s", SDL_GetError());
        return SDL_APP_FAILURE;
    }

    SDL_Log("\tCriando janela e renderizador...");
    if (!MyWindow_initialize(&g_window, "IMAGEM", DEFAULT_WINDOW_WIDTH, DEFAULT_WINDOW_HEIGHT, 0) ||
        !MyWindow_initialize(&h_window, "HISTOGRAMA", DEFAULT_H_WINDOW_WIDTH, DEFAULT_H_WINDOW_HEIGHT, 0))
    {
        SDL_Log("\tErro ao criar a janela e/ou renderizador: %s", SDL_GetError());
        SDL_Log("<<< initialize()");
        return SDL_APP_FAILURE;
    }
    SDL_Log("<<< initialize()");
    return SDL_APP_CONTINUE;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
static void shutdown(void)
{
    SDL_Log(">>> shutdown()");

    if (g_font) // <-- MODIFICADO
    {
        TTF_CloseFont(g_font);
    }

    MyImage_destroy(&g_image);
    MyWindow_destroy(&g_window);
    MyWindow_destroy(&h_window);

    SDL_Log("\tEncerrando SDL_ttf..."); // <-- MODIFICADO
    TTF_Quit(); // <-- MODIFICADO

    SDL_Log("\tEncerrando SDL...");
    SDL_Quit();

    SDL_Log("<<< shutdown()");
}

void render_histogram(int max_bar, char str_max_bar[5])
{
    int max_value = 1; 
    for (int i = 0; i < 256; i++)
    {
        if (histogram[i] > max_value)
            max_value = histogram[i];
    }
    max_bar = max_value;
    sprintf(str_max_bar, "%d", max_bar);

    float bar_width = (float)(DEFAULT_H_WINDOW_WIDTH - 80) / 256.0f; // <-- MODIFICADO (espaço para eixos)
    int graph_height = DEFAULT_H_WINDOW_HEIGHT - 240; // <-- MODIFICADO (espaço para eixos) //100
    int graph_y_start = 60; // <-- MODIFICADO

    for (int i = 0; i < 256; i++)
    {
        float bar_height = ((float)histogram[i] / max_value) * (graph_height - 40); 
        SDL_SetRenderDrawColor(h_window.renderer, 200, 200, 220, 255);

        SDL_FRect bar = {
            .x = 40 + i * bar_width, // <-- MODIFICADO (início em x=40)
            .y = graph_y_start + graph_height - bar_height, // <-- MODIFICADO
            .w = bar_width,
            .h = bar_height
        };
        SDL_RenderFillRect(h_window.renderer, &bar);
    }
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
static void render(void)
{
    SDL_SetRenderDrawColor(g_window.renderer, 128, 128, 128, 255);
    SDL_RenderClear(g_window.renderer);
    SDL_RenderTexture(g_window.renderer, g_image.texture, &g_image.rect, &g_image.rect);
    SDL_RenderPresent(g_window.renderer);

    // --- Renderização da janela do Histograma --- // <-- MODIFICADO
    SDL_SetRenderDrawColor(h_window.renderer, 40, 40, 60, 255); // Fundo escuro azulado
    SDL_RenderClear(h_window.renderer);
    
    char str_max_bar[6];
    int max_bar = 0;

    render_histogram(max_bar, str_max_bar);

    SDL_Color white = {255, 255, 255, 255};
    SDL_Color light_gray = {200, 200, 200, 255};

    // Título
    render_text(h_window.renderer, "Histograma de Intensidade", 150, 15, white);

    
    // Eixo Y (Frequência)
    render_text(h_window.renderer, "Frequencia", 10, 35, light_gray);
    render_text(h_window.renderer, str_max_bar, 20, 55, light_gray);
    //render_text(h_window.renderer, "0", 15, DEFAULT_H_WINDOW_HEIGHT - 45, light_gray);

    // Eixo X (Níveis de Cinza)
    render_text(h_window.renderer, "Niveis de Cinza", 210 , DEFAULT_H_WINDOW_HEIGHT - 170, light_gray);
    render_text(h_window.renderer, "0", 20 + 15, DEFAULT_H_WINDOW_HEIGHT - 170, light_gray);
    render_text(h_window.renderer, "255", DEFAULT_H_WINDOW_WIDTH - 65, DEFAULT_H_WINDOW_HEIGHT - 170, light_gray);

    // Exibir classificações de intensidade e desvio padrão
    float avg_intensity = (float) calculate_average_intensity();
    float std_deviation = (float)calculate_standard_deviation();
    classify_intensity((int)roundf(avg_intensity));
    classify_deviation(std_deviation);

     // Exibir valores numéricos de média e desvio padrão
    char str_avg_intensity[6];
    char str_std_deviation[6];
    sprintf(str_avg_intensity, "%.2f", avg_intensity);
    sprintf(str_std_deviation, "%.2f", std_deviation);

    render_text(h_window.renderer, "Media:", 20, 100, light_gray);
    render_text(h_window.renderer, str_avg_intensity, 80, 100, light_gray);
    render_text(h_window.renderer, "Desvio Padrao:", 20, 120, light_gray);
    render_text(h_window.renderer, str_std_deviation, 120, 120, light_gray);

    SDL_RenderPresent(h_window.renderer);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
static void loop(void)
{
    SDL_Log(">>> loop()");

    bool mustRefresh = false;
    render();

    SDL_Event event;
    bool isRunning = true;
    while (isRunning)
    {
        while (SDL_PollEvent(&event))
        {
            switch (event.type)
            {
            case SDL_EVENT_QUIT:
                isRunning = false;
                break;

            case SDL_EVENT_KEY_DOWN:
                if (event.key.key == SDLK_1 && !event.key.repeat)
                {
                    invert_image(g_window.renderer, &g_image);
                    mustRefresh = true;
                }
                break;

            case SDL_EVENT_WINDOW_CLOSE_REQUESTED:
            {
                SDL_WindowID windowID = event.window.windowID;

                if (windowID == SDL_GetWindowID(g_window.window))
                {
                    SDL_Log("Pedido para fechar a janela principal. Encerrando o programa.");
                    isRunning = false;
                }
                else if (windowID == SDL_GetWindowID(h_window.window))
                {
                    SDL_Log("Pedido para fechar a janela secundária.");
                    SDL_HideWindow(h_window.window);
                }

            }
            }
        }

        if (mustRefresh)
        {
            render();
            mustRefresh = false;
        }
    }
    
    SDL_Log("<<< loop()");
}


float calculate_intensity(Uint8 r, Uint8 g, Uint8 b)
{
    return (r + g + b) / 3.0f;
}


float calculate_average_intensity()
{
    int pixelCount = (int)g_image.rect.w * (int)g_image.rect.h;
    float soma = 0.0f;
    Uint32 *pixels = (Uint32 *)g_image.surface->pixels;

    for (int i = 0; i < pixelCount; i++)
    {
        Uint8 r = 0;
        Uint8 g = 0;
        Uint8 b = 0;
        Uint8 a = 0;

        const SDL_PixelFormatDetails *format = SDL_GetPixelFormatDetails(g_image.surface->format);
        SDL_GetRGBA(pixels[i], format, NULL, &r, &g, &b, &a);

        soma += calculate_intensity(r, g, b);
    }

    return soma / pixelCount;  
}


float calculate_standard_deviation()
{
    int pixelCount = (int)g_image.rect.w * (int)g_image.rect.h;
    float media = calculate_average_intensity();
    float soma = 0.0f;
    Uint32 *pixels = (Uint32 *)g_image.surface->pixels;

    for (int i = 0; i < pixelCount; i++)
    {
        Uint8 r = 0;
        Uint8 g = 0;
        Uint8 b = 0;
        Uint8 a = 0;

        const SDL_PixelFormatDetails *format = SDL_GetPixelFormatDetails(g_image.surface->format);
        SDL_GetRGBA(pixels[i], format, NULL, &r, &g, &b, &a);

        float intensidade = calculate_intensity(r, g, b);
        soma += (intensidade - media) * (intensidade - media);
    }

    float variancia = soma / pixelCount;
    float desvio_padrao = sqrt(variancia);

    return desvio_padrao;
}

void calculate_histogram()
{
    for(int i=0; i<256; ++i) histogram[i] = 0;

    int pixelCount = g_image.surface->w * g_image.surface->h;
    Uint32 *pixels = (Uint32 *)g_image.surface->pixels;
    const SDL_PixelFormatDetails *format = SDL_GetPixelFormatDetails(g_image.surface->format);

    SDL_LockSurface(g_image.surface);
    for (int i = 0; i < pixelCount; i++)
    {
        Uint8 r, g, b, a;
        SDL_GetRGBA(pixels[i], format, NULL, &r, &g, &b, &a);
        int intensity = (int)roundf(calculate_intensity(r, g, b));
        if (intensity >= 0 && intensity <= 255) {
            histogram[intensity]++;
        }
    }
    SDL_UnlockSurface(g_image.surface);
}




void classify_intensity(int intensity)
{
    if (intensity < 85)
        SDL_Log("Imagem escura");
    else if (intensity >= 85 && intensity <= 170)
        SDL_Log("Imagem de intensidade média");
    else
        SDL_Log("Imagem clara");
}


void classify_deviation(float deviation)
{
    if (deviation < 52.0f)
        SDL_Log("Imagem com baixo contraste");
    else if (deviation >= 52.0f && deviation <= 104.0f)
        SDL_Log("Imagem com contraste médio");
    else
        SDL_Log("Imagem com alto contraste");
}




//------------------------------------------------------------------------------
// main()
//------------------------------------------------------------------------------
int main(int argc, char *argv[])
{
    atexit(shutdown);

    if (argc < 2)
    {
        SDL_Log("Erro: O caminho para a imagem não foi fornecido.");
        SDL_Log("Uso: %s <arquivo_imagem>", argv[0]);
        return SDL_APP_FAILURE;
    }

    if (initialize() == SDL_APP_FAILURE)
        return SDL_APP_FAILURE;

    // Carrega a fonte // <-- ADICIONADO
    g_font = TTF_OpenFont(FONT_FILENAME, FONT_SIZE);
    if (!g_font)
    {
        SDL_Log("Erro ao carregar a fonte '%s': %s", FONT_FILENAME, SDL_GetError());
        return SDL_APP_FAILURE;
    }
    
    load_rgba32(argv[1], g_window.renderer, &g_image);

    calculate_histogram();

    int imageWidth = (int)g_image.rect.w;
    int imageHeight = (int)g_image.rect.h;

    if (imageWidth > DEFAULT_WINDOW_WIDTH || imageHeight > DEFAULT_WINDOW_HEIGHT)
    {
        int top = 0;
        int left = 0;
        SDL_GetWindowBordersSize(g_window.window, &top, &left, NULL, NULL);
        SDL_GetWindowBordersSize(h_window.window, &top, &left, NULL, NULL);

        SDL_Log("Redefinindo dimensões da janela, de (%d, %d) para (%d, %d), e alterando a posição para (%d, %d).",
        DEFAULT_WINDOW_WIDTH, DEFAULT_WINDOW_HEIGHT, imageWidth, imageHeight, left, top);

        SDL_SetWindowSize(g_window.window, imageWidth, imageHeight);
        SDL_SetWindowPosition(g_window.window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);

        int main_x, main_y, main_w, main_h;
        SDL_GetWindowPosition(g_window.window, &main_x, &main_y);
        SDL_GetWindowSize(g_window.window, &main_w, &main_h);

        int secondary_x, secondary_y;
        secondary_x = main_x + main_w + 10;
        secondary_y = main_y;
        SDL_SetWindowPosition(h_window.window, 10, SDL_WINDOWPOS_CENTERED);

        SDL_SyncWindow(g_window.window);
        SDL_SyncWindow(h_window.window);
    }

    loop();

    return 0;
}